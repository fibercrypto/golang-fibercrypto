// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	api "github.com/SkycoinProject/skycoin/src/api"
	coin "github.com/SkycoinProject/skycoin/src/coin"

	mock "github.com/stretchr/testify/mock"

	readable "github.com/SkycoinProject/skycoin/src/readable"
)

// SkycoinAPI is an autogenerated mock type for the SkycoinAPI type
type SkycoinAPI struct {
	mock.Mock
}

// Balance provides a mock function with given fields: addrs
func (_m *SkycoinAPI) Balance(addrs []string) (*api.BalanceResponse, error) {
	ret := _m.Called(addrs)

	var r0 *api.BalanceResponse
	if rf, ok := ret.Get(0).(func([]string) *api.BalanceResponse); ok {
		r0 = rf(addrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BalanceResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(addrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockchainProgress provides a mock function with given fields:
func (_m *SkycoinAPI) BlockchainProgress() (*readable.BlockchainProgress, error) {
	ret := _m.Called()

	var r0 *readable.BlockchainProgress
	if rf, ok := ret.Get(0).(func() *readable.BlockchainProgress); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*readable.BlockchainProgress)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CoinSupply provides a mock function with given fields:
func (_m *SkycoinAPI) CoinSupply() (*api.CoinSupply, error) {
	ret := _m.Called()

	var r0 *api.CoinSupply
	if rf, ok := ret.Get(0).(func() *api.CoinSupply); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CoinSupply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransaction provides a mock function with given fields: req
func (_m *SkycoinAPI) CreateTransaction(req api.CreateTransactionRequest) (*api.CreateTransactionResponse, error) {
	ret := _m.Called(req)

	var r0 *api.CreateTransactionResponse
	if rf, ok := ret.Get(0).(func(api.CreateTransactionRequest) *api.CreateTransactionResponse); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(api.CreateTransactionRequest) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWallet provides a mock function with given fields: o
func (_m *SkycoinAPI) CreateWallet(o api.CreateWalletOptions) (*api.WalletResponse, error) {
	ret := _m.Called(o)

	var r0 *api.WalletResponse
	if rf, ok := ret.Get(0).(func(api.CreateWalletOptions) *api.WalletResponse); ok {
		r0 = rf(o)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.WalletResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(api.CreateWalletOptions) error); ok {
		r1 = rf(o)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecryptWallet provides a mock function with given fields: id, password
func (_m *SkycoinAPI) DecryptWallet(id string, password string) (*api.WalletResponse, error) {
	ret := _m.Called(id, password)

	var r0 *api.WalletResponse
	if rf, ok := ret.Get(0).(func(string, string) *api.WalletResponse); ok {
		r0 = rf(id, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.WalletResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(id, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncryptWallet provides a mock function with given fields: id, password
func (_m *SkycoinAPI) EncryptWallet(id string, password string) (*api.WalletResponse, error) {
	ret := _m.Called(id, password)

	var r0 *api.WalletResponse
	if rf, ok := ret.Get(0).(func(string, string) *api.WalletResponse); ok {
		r0 = rf(id, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.WalletResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(id, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InjectEncodedTransaction provides a mock function with given fields: rawTxn
func (_m *SkycoinAPI) InjectEncodedTransaction(rawTxn string) (string, error) {
	ret := _m.Called(rawTxn)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(rawTxn)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(rawTxn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InjectTransaction provides a mock function with given fields: txn
func (_m *SkycoinAPI) InjectTransaction(txn *coin.Transaction) (string, error) {
	ret := _m.Called(txn)

	var r0 string
	if rf, ok := ret.Get(0).(func(*coin.Transaction) string); ok {
		r0 = rf(txn)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*coin.Transaction) error); ok {
		r1 = rf(txn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LastBlocks provides a mock function with given fields: n
func (_m *SkycoinAPI) LastBlocks(n uint64) (*readable.Blocks, error) {
	ret := _m.Called(n)

	var r0 *readable.Blocks
	if rf, ok := ret.Get(0).(func(uint64) *readable.Blocks); ok {
		r0 = rf(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*readable.Blocks)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(n)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetworkConnections provides a mock function with given fields: filters
func (_m *SkycoinAPI) NetworkConnections(filters *api.NetworkConnectionsFilter) (*api.Connections, error) {
	ret := _m.Called(filters)

	var r0 *api.Connections
	if rf, ok := ret.Get(0).(func(*api.NetworkConnectionsFilter) *api.Connections); ok {
		r0 = rf(filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Connections)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*api.NetworkConnectionsFilter) error); ok {
		r1 = rf(filters)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewWalletAddress provides a mock function with given fields: id, n, password
func (_m *SkycoinAPI) NewWalletAddress(id string, n int, password string) ([]string, error) {
	ret := _m.Called(id, n, password)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string, int, string) []string); ok {
		r0 = rf(id, n, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, string) error); ok {
		r1 = rf(id, n, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OutputsForAddresses provides a mock function with given fields: addrs
func (_m *SkycoinAPI) OutputsForAddresses(addrs []string) (*readable.UnspentOutputsSummary, error) {
	ret := _m.Called(addrs)

	var r0 *readable.UnspentOutputsSummary
	if rf, ok := ret.Get(0).(func([]string) *readable.UnspentOutputsSummary); ok {
		r0 = rf(addrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*readable.UnspentOutputsSummary)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(addrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PendingTransactionsVerbose provides a mock function with given fields:
func (_m *SkycoinAPI) PendingTransactionsVerbose() ([]readable.UnconfirmedTransactionVerbose, error) {
	ret := _m.Called()

	var r0 []readable.UnconfirmedTransactionVerbose
	if rf, ok := ret.Get(0).(func() []readable.UnconfirmedTransactionVerbose); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]readable.UnconfirmedTransactionVerbose)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transaction provides a mock function with given fields: txid
func (_m *SkycoinAPI) Transaction(txid string) (*readable.TransactionWithStatus, error) {
	ret := _m.Called(txid)

	var r0 *readable.TransactionWithStatus
	if rf, ok := ret.Get(0).(func(string) *readable.TransactionWithStatus); ok {
		r0 = rf(txid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*readable.TransactionWithStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(txid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransactionVerbose provides a mock function with given fields: txid
func (_m *SkycoinAPI) TransactionVerbose(txid string) (*readable.TransactionWithStatusVerbose, error) {
	ret := _m.Called(txid)

	var r0 *readable.TransactionWithStatusVerbose
	if rf, ok := ret.Get(0).(func(string) *readable.TransactionWithStatusVerbose); ok {
		r0 = rf(txid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*readable.TransactionWithStatusVerbose)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(txid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transactions provides a mock function with given fields: addrs
func (_m *SkycoinAPI) Transactions(addrs []string) ([]readable.TransactionWithStatus, error) {
	ret := _m.Called(addrs)

	var r0 []readable.TransactionWithStatus
	if rf, ok := ret.Get(0).(func([]string) []readable.TransactionWithStatus); ok {
		r0 = rf(addrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]readable.TransactionWithStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(addrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransactionsVerbose provides a mock function with given fields: addrs
func (_m *SkycoinAPI) TransactionsVerbose(addrs []string) ([]readable.TransactionWithStatusVerbose, error) {
	ret := _m.Called(addrs)

	var r0 []readable.TransactionWithStatusVerbose
	if rf, ok := ret.Get(0).(func([]string) []readable.TransactionWithStatusVerbose); ok {
		r0 = rf(addrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]readable.TransactionWithStatusVerbose)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(addrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWallet provides a mock function with given fields: id, label
func (_m *SkycoinAPI) UpdateWallet(id string, label string) error {
	ret := _m.Called(id, label)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(id, label)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UxOut provides a mock function with given fields: uxID
func (_m *SkycoinAPI) UxOut(uxID string) (*readable.SpentOutput, error) {
	ret := _m.Called(uxID)

	var r0 *readable.SpentOutput
	if rf, ok := ret.Get(0).(func(string) *readable.SpentOutput); ok {
		r0 = rf(uxID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*readable.SpentOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uxID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Wallet provides a mock function with given fields: id
func (_m *SkycoinAPI) Wallet(id string) (*api.WalletResponse, error) {
	ret := _m.Called(id)

	var r0 *api.WalletResponse
	if rf, ok := ret.Get(0).(func(string) *api.WalletResponse); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.WalletResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletBalance provides a mock function with given fields: id
func (_m *SkycoinAPI) WalletBalance(id string) (*api.BalanceResponse, error) {
	ret := _m.Called(id)

	var r0 *api.BalanceResponse
	if rf, ok := ret.Get(0).(func(string) *api.BalanceResponse); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BalanceResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletCreateTransaction provides a mock function with given fields: req
func (_m *SkycoinAPI) WalletCreateTransaction(req api.WalletCreateTransactionRequest) (*api.CreateTransactionResponse, error) {
	ret := _m.Called(req)

	var r0 *api.CreateTransactionResponse
	if rf, ok := ret.Get(0).(func(api.WalletCreateTransactionRequest) *api.CreateTransactionResponse); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(api.WalletCreateTransactionRequest) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletSignTransaction provides a mock function with given fields: req
func (_m *SkycoinAPI) WalletSignTransaction(req api.WalletSignTransactionRequest) (*api.CreateTransactionResponse, error) {
	ret := _m.Called(req)

	var r0 *api.CreateTransactionResponse
	if rf, ok := ret.Get(0).(func(api.WalletSignTransactionRequest) *api.CreateTransactionResponse); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CreateTransactionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(api.WalletSignTransactionRequest) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletUnconfirmedTransactionsVerbose provides a mock function with given fields: id
func (_m *SkycoinAPI) WalletUnconfirmedTransactionsVerbose(id string) (*api.UnconfirmedTxnsVerboseResponse, error) {
	ret := _m.Called(id)

	var r0 *api.UnconfirmedTxnsVerboseResponse
	if rf, ok := ret.Get(0).(func(string) *api.UnconfirmedTxnsVerboseResponse); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.UnconfirmedTxnsVerboseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Wallets provides a mock function with given fields:
func (_m *SkycoinAPI) Wallets() ([]api.WalletResponse, error) {
	ret := _m.Called()

	var r0 []api.WalletResponse
	if rf, ok := ret.Get(0).(func() []api.WalletResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.WalletResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
